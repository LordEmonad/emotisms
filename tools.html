<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>$EMO Tools ‚Äî Monad Utilities</title>
  <meta name="description" content="$EMO Tools ‚Äî Monad token utilities for holders & builders">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <style>
    @font-face {
      font-family: 'Space Grotesk';
      font-style: normal;
      font-weight: 500 800;
      font-display: swap;
      src: url(fonts/SpaceGrotesk-latin.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
    :root {
      --bg-color: #ffffff;
      --text-color: #1a1a1a;
      --text-secondary: #666666;
      --text-muted: #aaaaaa;
      --accent-color: #7B3FE4;
      --accent-light: #6930c3;
      --accent-dark: #5D2BB8;
      --accent-glow: rgba(123, 63, 228, 0.25);
      --button-bg: var(--accent-color);
      --button-hover: var(--accent-light);
      --button-text: #ffffff;
      --card-bg: #ffffff;
      --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      --contract-bg: #f5f3ff;
      --contract-border: #e4d8f8;
      --surface: #f5f3ff;
      --surface-border: #e4d8f8;
      --success-color: #22c55e;
      --error-color: #ef4444;
    }

    [data-theme="dark"] {
      --bg-color: #0a0a0a;
      --text-color: #ffffff;
      --text-secondary: #888888;
      --text-muted: #505050;
      --accent-color: #9B5FFF;
      --accent-light: #b080ff;
      --accent-dark: #7B3FE4;
      --accent-glow: rgba(155, 95, 255, 0.3);
      --card-bg: rgba(255, 255, 255, 0.04);
      --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      --contract-bg: rgba(255, 255, 255, 0.06);
      --contract-border: rgba(255, 255, 255, 0.1);
      --surface: rgba(255, 255, 255, 0.06);
      --surface-border: rgba(255, 255, 255, 0.1);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: radial-gradient(ellipse at 50% 0%, var(--accent-glow) 0%, transparent 55%), var(--bg-color);
      color: var(--text-color);
      font-family: 'Space Grotesk', sans-serif;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      line-height: 1.6;
    }

    /* ‚îÄ‚îÄ Page Transition ‚îÄ‚îÄ */
    .page-transition {
      position: fixed;
      inset: 0;
      z-index: 9999;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page-transition .pt-overlay {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 50% 50%, rgba(155, 95, 255, 0.15) 0%, transparent 60%),
        var(--bg-color);
      transform: scaleY(1);
      transform-origin: top;
      animation: ptOverlayOut 1.1s 0.25s cubic-bezier(0.77, 0, 0.175, 1) forwards;
    }

    .page-transition .pt-logo {
      position: relative;
      z-index: 1;
      opacity: 1;
      transform: scale(1) rotate(0deg);
      animation: ptLogoOut 0.8s cubic-bezier(0.77, 0, 0.175, 1) forwards;
    }

    .page-transition .pt-logo svg {
      width: 80px;
      height: 80px;
      filter: drop-shadow(0 0 30px rgba(155, 95, 255, 0.6));
    }

    .page-transition .pt-glow {
      position: absolute;
      inset: -20px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(155, 95, 255, 0.3) 0%, transparent 70%);
      opacity: 0.6;
      animation: ptGlowOut 0.7s ease forwards;
    }

    @keyframes ptOverlayOut {
      0% { transform: scaleY(1); }
      100% { transform: scaleY(0); }
    }

    @keyframes ptLogoOut {
      0% { opacity: 1; transform: scale(1) rotate(0deg); }
      100% { opacity: 0; transform: scale(1.3) rotate(15deg); }
    }

    @keyframes ptGlowOut {
      0% { opacity: 0.6; transform: scale(1); }
      100% { opacity: 0; transform: scale(2); }
    }

    .page-enter {
      animation: ptPageEnter 1.1s 0.3s cubic-bezier(0.16, 1, 0.3, 1) both;
    }

    @keyframes ptPageEnter {
      0% { opacity: 0; transform: translateY(25px); filter: blur(3px); }
      100% { opacity: 1; transform: translateY(0); filter: blur(0); }
    }

    /* ‚îÄ‚îÄ Exit transition (back to emo) ‚îÄ‚îÄ */
    .page-transition.exit-active {
      pointer-events: all;
    }

    .page-transition.exit-active .pt-overlay {
      transform: scaleY(0);
      transform-origin: bottom;
      animation: ptOverlayIn 1.1s cubic-bezier(0.77, 0, 0.175, 1) forwards;
    }

    .page-transition.exit-active .pt-logo {
      opacity: 0;
      transform: scale(0.5) rotate(-30deg);
      animation: ptLogoIn 1.0s 0.45s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    .page-transition.exit-active .pt-glow {
      opacity: 0;
      animation: ptGlowPulse 1.1s 0.55s ease forwards;
    }

    @keyframes ptOverlayIn {
      0% { transform: scaleY(0); transform-origin: bottom; }
      100% { transform: scaleY(1); transform-origin: bottom; }
    }

    @keyframes ptLogoIn {
      0% { opacity: 0; transform: scale(0.5) rotate(-30deg); }
      60% { opacity: 1; transform: scale(1.08) rotate(5deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }

    @keyframes ptGlowPulse {
      0% { opacity: 0; transform: scale(0.5); }
      50% { opacity: 1; transform: scale(1.2); }
      100% { opacity: 0.6; transform: scale(1); }
    }

    .page-transition.exit-active ~ .price-ticker,
    .page-transition.exit-active ~ .container {
      animation: ptContentOut 0.95s cubic-bezier(0.77, 0, 0.175, 1) forwards;
    }

    @keyframes ptContentOut {
      0% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
      100% { opacity: 0; transform: translateY(-40px) scale(0.97); filter: blur(4px); }
    }

    @media (prefers-reduced-motion: reduce) {
      .page-transition { display: none; }
      .page-enter { animation: none; opacity: 1; }
    }

    /* Theme Transition */
    html.theme-transition,
    html.theme-transition *,
    html.theme-transition *::before,
    html.theme-transition *::after {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease !important;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 72px 20px 40px;
    }

    /* Price Ticker Header */
    .price-ticker {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-bottom: 1px solid var(--surface-border);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      padding: 0 20px;
      height: 52px;
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
      font-weight: 600;
      z-index: 100;
    }

    .price-ticker .token-name {
      color: var(--accent-color);
    }

    .price-ticker .price {
      color: var(--text-color);
      font-size: 16px;
    }

    .price-ticker .change {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 13px;
    }

    .price-ticker .change.positive {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
    }

    .price-ticker .change.negative {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .price-ticker .mcap {
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
    }

    /* Theme Toggle in Header */
    .theme-toggle-header {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--surface-border);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      transition: all 0.25s ease;
      flex-shrink: 0;
      position: relative;
    }

    .theme-toggle-header:hover {
      border-color: var(--accent-color);
      background: var(--accent-glow);
    }

    .theme-toggle-header:focus-visible {
      outline: 2px solid var(--accent-color);
      outline-offset: 2px;
    }

    .theme-toggle-header .icon-sun,
    .theme-toggle-header .icon-moon {
      position: absolute;
      transition: all 0.3s ease;
    }

    .theme-toggle-header .icon-sun {
      opacity: 0;
      transform: rotate(-90deg);
    }

    .theme-toggle-header .icon-moon {
      opacity: 1;
      transform: rotate(0deg);
    }

    [data-theme="dark"] .theme-toggle-header .icon-sun {
      opacity: 1;
      transform: rotate(0deg);
    }

    [data-theme="dark"] .theme-toggle-header .icon-moon {
      opacity: 0;
      transform: rotate(90deg);
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text-color);
      text-decoration: none;
      font-weight: 600;
      font-size: 14px;
      padding: 7px 16px;
      border-radius: 999px;
      border: 1px solid var(--surface-border);
      background: transparent;
      transition: all 0.25s ease;
    }

    .back-btn:hover {
      border-color: var(--accent-color);
      color: var(--accent-color);
      background: var(--accent-glow);
    }

    .back-btn:focus-visible {
      outline: 2px solid var(--accent-color);
      outline-offset: 2px;
    }

    @media (max-width: 768px) {
      .price-ticker {
        height: 46px;
        gap: 10px;
        padding: 0 12px;
        font-size: 11px;
      }
      .price-ticker .mcap {
        display: none;
      }
      .back-btn { font-size: 12px; padding: 5px 12px; }
      .theme-toggle-header { width: 30px; height: 30px; font-size: 14px; }
    }

    /* Page Title */
    .page-title {
      text-align: center;
      margin-bottom: 40px;
    }

    .page-title h1 {
      font-size: 2.2rem;
      font-weight: 800;
      letter-spacing: -0.5px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, var(--accent-color), var(--text-color) 70%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .page-title h1 span {
      -webkit-text-fill-color: inherit;
    }

    .page-title p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    /* Tool Card */
    .tool-card {
      background: var(--card-bg);
      border-radius: 20px;
      border: 1px solid var(--contract-border);
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: var(--card-shadow);
    }

    .tool-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--contract-border);
    }

    .tool-icon {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, var(--accent-color), var(--accent-dark));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }

    .tool-title h2 {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-color);
      margin-bottom: 4px;
    }

    .tool-title p {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-color);
    }

    .form-group .hint {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 6px;
    }

    .form-group .hint a {
      color: var(--accent-color);
      text-decoration: none;
    }

    .form-group .hint a:hover {
      text-decoration: underline;
    }

    .input-field {
      width: 100%;
      padding: 14px 18px;
      border-radius: 12px;
      border: 2px solid var(--contract-border);
      background: var(--contract-bg);
      color: var(--text-color);
      font-family: 'Space Grotesk', monospace;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(123, 63, 228, 0.2);
    }

    .input-field::placeholder {
      color: var(--text-secondary);
    }

    .input-row {
      display: flex;
      gap: 15px;
    }

    .input-row .form-group {
      flex: 1;
    }

    .input-row .form-group.small {
      flex: 0 0 120px;
    }

    /* Buttons */
    .btn {
      background: var(--accent-color);
      color: white;
      border: none;
      padding: 14px 28px;
      border-radius: 12px;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn:hover {
      background: var(--accent-light);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(123, 63, 228, 0.4);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .btn.secondary {
      background: var(--contract-bg);
      color: var(--text-color);
      border: 2px solid var(--contract-border);
    }

    .btn.secondary:hover {
      background: var(--contract-border);
    }

    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* Results Area */
    .results-area {
      margin-top: 25px;
      display: none;
    }

    .results-area.active {
      display: block;
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .results-header h3 {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-color);
    }

    .results-stats {
      display: flex;
      gap: 20px;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .results-table th,
    .results-table td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid var(--contract-border);
    }

    .results-table th {
      background: var(--contract-bg);
      font-weight: 600;
      color: var(--text-color);
      position: sticky;
      top: 0;
    }

    .results-table tr:hover {
      background: rgba(123, 63, 228, 0.05);
    }

    .results-table .address {
      font-family: monospace;
      font-size: 12px;
      color: var(--accent-color);
    }

    .results-table .amount {
      text-align: right;
      font-weight: 600;
    }

    .results-table .percentage {
      text-align: right;
      color: var(--text-secondary);
    }

    .results-container {
      max-height: 500px;
      overflow-y: auto;
      border-radius: 12px;
      border: 1px solid var(--contract-border);
    }

    .results-container::-webkit-scrollbar {
      width: 8px;
    }

    .results-container::-webkit-scrollbar-track {
      background: var(--contract-bg);
      border-radius: 4px;
    }

    .results-container::-webkit-scrollbar-thumb {
      background: var(--accent-color);
      border-radius: 4px;
    }

    /* Status Messages */
    .status {
      padding: 12px 18px;
      border-radius: 10px;
      margin-top: 15px;
      font-weight: 500;
      display: none;
    }

    .status.active {
      display: block;
    }

    .status.loading {
      background: rgba(123, 63, 228, 0.15);
      color: var(--accent-color);
      border: 1px solid var(--accent-color);
    }

    .status.success {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success-color);
      border: 1px solid var(--success-color);
    }

    .status.error {
      background: rgba(239, 68, 68, 0.15);
      color: var(--error-color);
      border: 1px solid var(--error-color);
    }

    /* API Key Notice */
    .api-notice {
      background: linear-gradient(135deg, rgba(123, 63, 228, 0.1), rgba(123, 63, 228, 0.05));
      border: 1px solid var(--accent-color);
      border-radius: 12px;
      padding: 15px 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .api-notice .notice-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .api-notice .notice-text {
      font-size: 0.9rem;
      color: var(--text-color);
    }

    .api-notice .notice-text strong {
      color: var(--accent-color);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 62px 15px 30px;
      }

      .page-title h1 {
        font-size: 1.8rem;
      }

      .tool-card {
        padding: 20px;
      }

      .input-row {
        flex-direction: column;
      }

      .input-row .form-group.small {
        flex: 1;
      }

      .btn-group {
        flex-direction: column;
      }

      .btn {
        width: 100%;
        justify-content: center;
      }

      .results-table {
        font-size: 12px;
      }

      .results-table th,
      .results-table td {
        padding: 10px 8px;
      }

      .results-table .address {
        font-size: 10px;
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .header-title {
        font-size: 1.1rem;
      }
    }

    /* Coming Soon Badge */
    .coming-soon {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 10px;
    }

    .tool-card.disabled {
      opacity: 0.6;
      pointer-events: none;
    }

    /* Collapsible Tool Cards */
    .tool-card.collapsed .tool-content {
      display: none;
    }

    .tool-header {
      cursor: pointer;
      user-select: none;
    }

    .tool-header .toggle-icon {
      margin-left: auto;
      font-size: 1.2rem;
      transition: transform 0.3s ease;
    }

    .tool-card.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }

    /* Token Cards */
    .token-card {
      background: var(--contract-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .token-card .token-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .token-card .token-name {
      font-weight: 600;
      color: var(--text-color);
    }

    .token-card .token-address {
      font-family: monospace;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .token-card .token-balance {
      text-align: right;
    }

    .token-card .token-amount {
      font-weight: 700;
      color: var(--text-color);
    }

    .token-card .token-value {
      font-size: 0.85rem;
      color: var(--success-color);
    }

    /* Trade Cards */
    .trade-card {
      background: var(--contract-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 12px 15px;
      margin-bottom: 8px;
      display: grid;
      grid-template-columns: 80px 1fr 1fr 100px;
      align-items: center;
      gap: 10px;
    }

    .trade-card .trade-type {
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 6px;
      text-align: center;
      font-size: 0.85rem;
    }

    .trade-card .trade-type.buy {
      background: rgba(34, 197, 94, 0.2);
      color: var(--success-color);
    }

    .trade-card .trade-type.sell {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error-color);
    }

    .trade-card .trade-amount {
      font-weight: 600;
    }

    .trade-card .trade-price {
      color: var(--text-secondary);
    }

    .trade-card .trade-time {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-align: right;
    }

    /* Pool Cards */
    .pool-card {
      background: var(--contract-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 10px;
    }

    .pool-card .pool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .pool-card .pool-pair {
      font-weight: 700;
      color: var(--text-color);
    }

    .pool-card .pool-dex {
      background: var(--accent-color);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .pool-card .pool-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .pool-card .pool-stat {
      text-align: center;
    }

    .pool-card .pool-stat-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 2px;
    }

    .pool-card .pool-stat-value {
      font-weight: 600;
      color: var(--text-color);
    }

    /* Tabs */
    .tool-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tool-tab {
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid var(--contract-border);
      background: var(--contract-bg);
      color: var(--text-color);
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .tool-tab:hover {
      border-color: var(--accent-color);
    }

    .tool-tab.active {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
    }

    /* Global API Key Section */
    .global-api-section {
      background: linear-gradient(135deg, rgba(123, 63, 228, 0.15), rgba(123, 63, 228, 0.05));
      border: 2px solid var(--accent-color);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .global-api-section h3 {
      margin-bottom: 15px;
      color: var(--accent-color);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .api-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .api-status.connected {
      background: rgba(34, 197, 94, 0.2);
      color: var(--success-color);
    }

    .api-status.disconnected {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error-color);
    }

    .api-status .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    @media (max-width: 768px) {
      .trade-card {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .trade-card .trade-time {
        grid-column: span 2;
        text-align: left;
      }

      .pool-card .pool-stats {
        grid-template-columns: 1fr;
      }
    }

    /* Dashboard Styles */
    .dashboard-header {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 20px;
      background: var(--card-bg);
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--contract-border);
    }

    .dashboard-header .token-icon {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--accent-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }

    .dashboard-header .token-info h3 {
      font-size: 1.4rem;
      margin-bottom: 4px;
    }

    .dashboard-header .token-info .token-ca {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: monospace;
    }

    .dashboard-header .token-price {
      margin-left: auto;
      text-align: right;
    }

    .dashboard-header .token-price .price {
      font-size: 1.6rem;
      font-weight: 700;
    }

    .dashboard-header .token-price .change {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .dashboard-header .token-price .change.positive {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .dashboard-header .token-price .change.negative {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .dashboard-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: var(--card-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
      text-align: center;
    }

    .stat-card .stat-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-card .stat-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-color);
    }

    .dashboard-intervals {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
    }

    .interval-card {
      background: var(--card-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
    }

    .interval-card .interval-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--contract-border);
    }

    .interval-card .interval-label {
      font-weight: 700;
      font-size: 1rem;
      color: var(--accent-color);
    }

    .interval-card .interval-change {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .interval-card .interval-change.positive {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .interval-card .interval-change.negative {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .interval-card .interval-stats {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .interval-card .interval-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
    }

    .interval-card .interval-row .label {
      color: var(--text-secondary);
    }

    .interval-card .interval-row .value {
      font-weight: 600;
    }

    .interval-card .interval-row .value.buy {
      color: #22c55e;
    }

    .interval-card .interval-row .value.sell {
      color: #ef4444;
    }

    .buy-sell-bar {
      height: 6px;
      background: #ef4444;
      border-radius: 3px;
      margin-top: 10px;
      overflow: hidden;
    }

    .buy-sell-bar .buy-portion {
      height: 100%;
      background: #22c55e;
      border-radius: 3px 0 0 3px;
    }

    @media (max-width: 900px) {
      .dashboard-stats {
        grid-template-columns: repeat(2, 1fr);
      }
      .dashboard-intervals {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 500px) {
      .dashboard-stats {
        grid-template-columns: 1fr;
      }
      .dashboard-intervals {
        grid-template-columns: 1fr;
      }
      .dashboard-header {
        flex-direction: column;
        text-align: center;
      }
      .dashboard-header .token-price {
        margin-left: 0;
        margin-top: 15px;
        text-align: center;
      }
    }

    /* Diamond Hand Analyzer Styles */
    .diamond-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }

    .diamond-stat {
      background: var(--card-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
      text-align: center;
    }

    .diamond-stat.highlight {
      background: rgba(123, 63, 228, 0.1);
      border-color: var(--accent-color);
    }

    .diamond-stat .stat-icon {
      font-size: 1.5rem;
      margin-bottom: 8px;
    }

    .diamond-stat .stat-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }

    .diamond-stat .stat-value {
      font-size: 1.3rem;
      font-weight: 700;
    }

    .diamond-stat .stat-value.diamond {
      color: #60a5fa;
    }

    .diamond-stat .stat-value.gold {
      color: #fbbf24;
    }

    .diamond-stat .stat-value.green {
      color: #22c55e;
    }

    .diamond-card {
      background: var(--card-bg);
      border: 1px solid var(--contract-border);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .diamond-card .rank {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-secondary);
      min-width: 35px;
    }

    .diamond-card .rank.top3 {
      color: #fbbf24;
    }

    .diamond-card .holder-info {
      flex: 1;
    }

    .diamond-card .holder-address {
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .diamond-card .holder-stats {
      display: flex;
      gap: 15px;
      margin-top: 5px;
      font-size: 0.85rem;
    }

    .diamond-card .diamond-score {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 70px;
    }

    .diamond-card .score-value {
      font-size: 1.4rem;
      font-weight: 700;
      color: #60a5fa;
    }

    .diamond-card .score-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
    }

    .diamond-card .tier-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .tier-badge.og {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .tier-badge.diamond {
      background: rgba(96, 165, 250, 0.2);
      color: #60a5fa;
    }

    .tier-badge.accumulator {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .tier-badge.steady {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .tier-badge.paper {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    @media (max-width: 768px) {
      .diamond-summary {
        grid-template-columns: repeat(2, 1fr);
      }
      .diamond-card {
        flex-direction: column;
        text-align: center;
      }
      .diamond-card .holder-stats {
        justify-content: center;
      }
    }

    /* Deep Dive Button & Results */
    .deep-dive-btn {
      padding: 8px 12px !important;
      min-width: auto !important;
      font-size: 1rem !important;
    }

    .deep-dive-btn.loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .deep-dive-results {
      margin-top: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      border: 1px solid var(--contract-border);
    }

    .deep-dive-results .dive-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 10px;
    }

    .deep-dive-results .dive-stat {
      text-align: center;
    }

    .deep-dive-results .dive-stat .label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
    }

    .deep-dive-results .dive-stat .value {
      font-size: 0.95rem;
      font-weight: 700;
    }

    .deep-dive-results .dive-stat .value.green {
      color: #22c55e;
    }

    .deep-dive-results .dive-stat .value.red {
      color: #ef4444;
    }

    .deep-dive-results .dive-stat .value.blue {
      color: #60a5fa;
    }

    .deep-dive-results .dive-summary {
      font-size: 0.85rem;
      color: var(--text-secondary);
      border-top: 1px solid var(--contract-border);
      padding-top: 10px;
      margin-top: 5px;
    }

    @media (max-width: 500px) {
      .deep-dive-results .dive-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <!-- Page Entrance Transition -->
  <div class="page-transition" id="pageTransition" aria-hidden="true">
    <div class="pt-overlay"></div>
    <div class="pt-logo">
      <div class="pt-glow"></div>
      <svg viewBox="0 0 24 24"><path fill="#836EF9" d="M12 3c-2.599 0-9 6.4-9 9s6.401 9 9 9s9-6.401 9-9s-6.401-9-9-9m-1.402 14.146c-1.097-.298-4.043-5.453-3.744-6.549s5.453-4.042 6.549-3.743c1.095.298 4.042 5.453 3.743 6.549c-.298 1.095-5.453 4.042-6.549 3.743"/></svg>
    </div>
  </div>

  <!-- Top Bar -->
  <div class="price-ticker page-enter">
    <a href="emo.html" class="back-btn" aria-label="Back to main site">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="15 18 9 12 15 6"/></svg>
      $EMO
    </a>
    <span class="token-name">$EMO</span>
    <span class="price" id="tokenPrice">Loading...</span>
    <span class="change" id="priceChange">--</span>
    <span class="mcap" id="marketCap"></span>
    <span style="flex:1"></span>
    <button class="theme-toggle-header" id="themeToggle" aria-label="Toggle dark and light theme">
      <span class="icon-sun">&#9680;</span>
      <span class="icon-moon">&#9681;</span>
    </button>
  </div>

  <div class="container page-enter" style="animation-delay: 0.05s">
    <!-- Page Title -->
    <div class="page-title">
      <h1><span>$EMO</span> Tools</h1>
      <p>Utilities for Monad meme coin holders & builders</p>
    </div>

    <!-- Global API Key Section -->
    <div class="global-api-section">
      <h3>üîê BlockVision API Key <span class="api-status disconnected" id="apiStatus"><span class="status-dot"></span> Not Set</span></h3>
      <div class="form-group" style="margin-bottom: 10px;">
        <input type="password" class="input-field" id="globalApiKey" placeholder="Enter your BlockVision API key">
      </div>
      <p class="hint" style="margin: 0;">Your key stays in your browser only. Get a free key at <a href="https://dashboard.blockvision.org/overview" target="_blank">BlockVision Dashboard</a> (10M free compute units).</p>
    </div>

    <!-- Tool 1: Token Holder Snapshot -->
    <div class="tool-card" id="tool-snapshot">
      <div class="tool-header" onclick="toggleTool('tool-snapshot')">
        <div class="tool-icon">üì∏</div>
        <div class="tool-title">
          <h2>Token Holder Snapshot</h2>
          <p>Get top holders of any Monad token instantly</p>
        </div>
        <span class="toggle-icon">‚ñº</span>
      </div>
      <div class="tool-content">
        <div class="input-row">
          <div class="form-group">
            <label>Token Contract Address</label>
            <input type="text" class="input-field" id="snapshotTokenAddress" placeholder="0x..." value="0x81A224F8A62f52BdE942dBF23A56df77A10b7777">
          </div>
          <div class="form-group small">
            <label>Top Holders</label>
            <input type="number" class="input-field" id="snapshotTopCount" value="50" min="1" max="500">
          </div>
        </div>
        <div class="btn-group">
          <button class="btn" onclick="fetchHolders()">üì∏ Take Snapshot</button>
          <button class="btn secondary" id="exportCsvBtn" onclick="exportSnapshotCSV()" style="display: none;">üì• CSV</button>
          <button class="btn secondary" id="exportJsonBtn" onclick="exportSnapshotJSON()" style="display: none;">üì• JSON</button>
          <button class="btn secondary" id="exportTxtBtn" onclick="exportSnapshotTXT()" style="display: none;">üì• TXT</button>
          <button class="btn secondary" id="copyAddressesBtn" onclick="copySnapshotAddresses()" style="display: none;">üìã Copy All</button>
        </div>
        <div class="status" id="snapshotStatus"></div>
        <div class="results-area" id="snapshotResults">
          <div class="results-header">
            <h3 id="snapshotTokenName">Token Holders</h3>
            <div class="results-stats">
              <span id="snapshotTotalHolders">0 holders</span>
              <span id="snapshotTime"></span>
            </div>
          </div>
          <div class="results-container">
            <table class="results-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Address</th>
                  <th class="amount">Amount</th>
                  <th class="percentage">%</th>
                </tr>
              </thead>
              <tbody id="snapshotTable"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Tool 2: Wallet Checker -->
    <div class="tool-card collapsed" id="tool-wallet">
      <div class="tool-header" onclick="toggleTool('tool-wallet')">
        <div class="tool-icon">üëõ</div>
        <div class="tool-title">
          <h2>Wallet Checker</h2>
          <p>View all tokens & NFTs held by any wallet</p>
        </div>
        <span class="toggle-icon">‚ñº</span>
      </div>
      <div class="tool-content">
        <div class="form-group">
          <label>Wallet Address</label>
          <input type="text" class="input-field" id="walletAddress" placeholder="0x...">
        </div>
        <div class="btn-group">
          <button class="btn" onclick="checkWallet()">üëõ Check Wallet</button>
          <button class="btn secondary" id="exportWalletCsvBtn" onclick="exportWalletCSV()" style="display: none;">üì• CSV</button>
          <button class="btn secondary" id="copyWalletBtn" onclick="copyWalletAddress()" style="display: none;">üìã Copy</button>
        </div>
        <div class="status" id="walletStatus"></div>
        <div class="results-area" id="walletResults">
          <div class="results-header">
            <h3>Token Holdings</h3>
            <div class="results-stats">
              <span id="walletTotalTokens">0 tokens</span>
              <span id="walletTotalValue"></span>
            </div>
          </div>
          <div id="walletTokenList"></div>
          
          <!-- NFT Holdings Section -->
          <div class="results-header" id="walletNftHeader" style="margin-top: 20px; display: none;">
            <h3>üñºÔ∏è NFT Holdings</h3>
            <div class="results-stats">
              <span id="walletTotalNfts">0 NFTs</span>
            </div>
          </div>
          <div id="walletNftList"></div>
        </div>
      </div>
    </div>

    <!-- Tool 3: Whale Watcher -->
    <div class="tool-card collapsed" id="tool-whale">
      <div class="tool-header" onclick="toggleTool('tool-whale')">
        <div class="tool-icon">üêã</div>
        <div class="tool-title">
          <h2>Whale Watcher</h2>
          <p>See what top holders are also holding</p>
        </div>
        <span class="toggle-icon">‚ñº</span>
      </div>
      <div class="tool-content">
        <div class="input-row">
          <div class="form-group">
            <label>Token Contract Address</label>
            <input type="text" class="input-field" id="whaleTokenAddress" placeholder="0x..." value="0x81A224F8A62f52BdE942dBF23A56df77A10b7777">
          </div>
          <div class="form-group small">
            <label>Top Whales</label>
            <input type="number" class="input-field" id="whaleCount" value="10" min="1" max="50">
          </div>
        </div>
        <div class="btn-group">
          <button class="btn" onclick="watchWhales()">üêã Analyze Whales</button>
          <button class="btn secondary" id="exportWhaleCsvBtn" onclick="exportWhaleCSV()" style="display: none;">üì• CSV</button>
          <button class="btn secondary" id="exportWhaleTxtBtn" onclick="exportWhaleTXT()" style="display: none;">üì• TXT</button>
        </div>
        <div class="status" id="whaleStatus"></div>
        <div class="results-area" id="whaleResults">
          <div class="results-header">
            <h3>Whale Holdings</h3>
          </div>
          <div id="whaleList"></div>
        </div>
      </div>
    </div>

    <!-- Tool 4: Diamond Hand Analyzer -->
    <div class="tool-card collapsed" id="tool-diamond">
      <div class="tool-header" onclick="toggleTool('tool-diamond')">
        <div class="tool-icon">üíé</div>
        <div class="tool-title">
          <h2>Diamond Hand Analyzer</h2>
          <p>Analyze holder strength & identify loyal diamond hands</p>
        </div>
        <span class="toggle-icon">‚ñº</span>
      </div>
      <div class="tool-content">
        <div class="input-row">
          <div class="form-group">
            <label>Token Contract Address</label>
            <input type="text" class="input-field" id="diamondTokenAddress" placeholder="0x..." value="0x81A224F8A62f52BdE942dBF23A56df77A10b7777">
          </div>
          <div class="form-group small">
            <label>Analyze Top</label>
            <input type="number" class="input-field" id="diamondCount" value="25" min="5" max="50">
          </div>
        </div>
        <div class="btn-group">
          <button class="btn" onclick="analyzeDiamondHands()">üíé Analyze Diamond Hands</button>
          <button class="btn secondary" id="exportDiamondCsvBtn" onclick="exportDiamondCSV()" style="display: none;">üì• CSV</button>
          <button class="btn secondary" id="exportDiamondTxtBtn" onclick="exportDiamondTXT()" style="display: none;">üì• TXT</button>
        </div>
        <div class="status" id="diamondStatus"></div>
        <div class="results-area" id="diamondResults">
          <!-- Summary Stats -->
          <div class="diamond-summary" id="diamondSummary"></div>
          <!-- Holder List -->
          <div class="results-header">
            <h3 id="diamondTokenName">Diamond Hand Rankings</h3>
          </div>
          <div id="diamondList"></div>
        </div>
      </div>
    </div>

    <!-- Tool 5: NFT Holder Snapshot -->
    <div class="tool-card collapsed" id="tool-nft">
      <div class="tool-header" onclick="toggleTool('tool-nft')">
        <div class="tool-icon">üñºÔ∏è</div>
        <div class="tool-title">
          <h2>NFT Holder Snapshot</h2>
          <p>Get holders of any Monad NFT collection</p>
        </div>
        <span class="toggle-icon">‚ñº</span>
      </div>
      <div class="tool-content">
        <!-- Find NFT Contract Address -->
        <div class="api-notice" style="margin-bottom: 20px;">
          <span class="notice-icon">üí°</span>
          <div class="notice-text">
            <strong>Need the contract address?</strong> Browse all Monad NFT collections on MonadVision to find and copy the contract address.
            <div style="margin-top: 10px;">
              <a href="https://monadvision.com/nfts" target="_blank" class="btn" style="display: inline-flex; padding: 8px 16px; text-decoration: none; font-size: 14px;">
                üîç Browse NFT Collections on MonadVision
              </a>
            </div>
          </div>
        </div>

        <!-- Direct Address Input -->
        <div class="input-row">
          <div class="form-group">
            <label>NFT Contract Address</label>
            <input type="text" class="input-field" id="nftAddress" placeholder="0x...">
          </div>
          <div class="form-group small">
            <label>Top Holders</label>
            <input type="number" class="input-field" id="nftTopCount" value="50" min="1" max="500">
          </div>
        </div>
        <div class="btn-group">
          <button class="btn" onclick="fetchNFTHolders()">üñºÔ∏è Take Snapshot</button>
          <button class="btn secondary" id="exportNftCsvBtn" onclick="exportNFTCSV()" style="display: none;">üì• CSV</button>
          <button class="btn secondary" id="exportNftTxtBtn" onclick="exportNFTTXT()" style="display: none;">üì• TXT</button>
          <button class="btn secondary" id="copyNftAddressesBtn" onclick="copyNFTAddresses()" style="display: none;">üìã Copy All</button>
        </div>
        <div class="status" id="nftStatus"></div>
        <div class="results-area" id="nftResults">
          <div class="results-header">
            <h3 id="nftCollectionTitle">NFT Holders</h3>
            <div class="results-stats">
              <span id="nftTotalHolders">0 holders</span>
              <span id="nftTotalSupply"></span>
            </div>
          </div>
          <div class="results-container">
            <table class="results-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Address</th>
                  <th class="amount">NFTs Held</th>
                  <th class="percentage">%</th>
                </tr>
              </thead>
              <tbody id="nftTable"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script>
    // --- state ---
    let snapshotData = [];
    let nftData = [];
    let whaleData = [];
    let walletTokenData = [];
    let walletNftData = [];
    let diamondData = [];

    // --- price ticker ---
    async function fetchPrice() {
      try {
        const response = await fetch('https://api.dexscreener.com/latest/dex/pairs/monad/0x714a2694c8d4f0b1bfba0e5b76240e439df2182d');
        const data = await response.json();
        if (data.pair) {
          const price = parseFloat(data.pair.priceUsd);
          const change24h = parseFloat(data.pair.priceChange.h24);
          const mcap = data.pair.marketCap;
          
          document.getElementById('tokenPrice').textContent = '$' + price.toFixed(7);
          
          const changeEl = document.getElementById('priceChange');
          changeEl.textContent = (change24h >= 0 ? '+' : '') + change24h.toFixed(2) + '%';
          changeEl.className = 'change ' + (change24h >= 0 ? 'positive' : 'negative');
          
          if (mcap) {
            const mcapFormatted = mcap >= 1000000 ? (mcap / 1000000).toFixed(2) + 'M' : (mcap / 1000).toFixed(1) + 'K';
            document.getElementById('marketCap').textContent = 'MC: $' + mcapFormatted;
          }
        }
      } catch (error) {
        console.log('Price fetch error:', error);
        document.getElementById('tokenPrice').textContent = '--';
      }
    }
    
    fetchPrice();
    setInterval(fetchPrice, 30000);

    // --- theme toggle ---
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;

    const savedTheme = localStorage.getItem('theme') ||
      (window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
    html.setAttribute('data-theme', savedTheme);

    themeToggle.addEventListener('click', () => {
      html.classList.add('theme-transition');
      const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      setTimeout(() => html.classList.remove('theme-transition'), 350);
    });

    // --- api key ---
    const apiKeyInput = document.getElementById('globalApiKey');
    const apiStatus = document.getElementById('apiStatus');

    // Load saved API key
    const savedApiKey = localStorage.getItem('blockvision_api_key');
    if (savedApiKey) {
      apiKeyInput.value = savedApiKey;
      updateApiStatus(true);
    }

    apiKeyInput.addEventListener('input', () => {
      const key = apiKeyInput.value.trim();
      if (key) {
        localStorage.setItem('blockvision_api_key', key);
        updateApiStatus(true);
      } else {
        localStorage.removeItem('blockvision_api_key');
        updateApiStatus(false);
      }
    });

    function updateApiStatus(connected) {
      if (connected) {
        apiStatus.className = 'api-status connected';
        apiStatus.innerHTML = '<span class="status-dot"></span> Connected';
      } else {
        apiStatus.className = 'api-status disconnected';
        apiStatus.innerHTML = '<span class="status-dot"></span> Not Set';
      }
    }

    function getApiKey() {
      return apiKeyInput.value.trim();
    }

    // --- tool toggle ---
    function toggleTool(toolId) {
      const tool = document.getElementById(toolId);
      tool.classList.toggle('collapsed');
    }

    // --- utils ---
    function showStatus(elementId, message, type) {
      const status = document.getElementById(elementId);
      status.textContent = message;
      status.className = `status active ${type}`;
    }

    function hideStatus(elementId) {
      const status = document.getElementById(elementId);
      status.className = 'status';
    }

    function downloadFile(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function validateAddress(address) {
      return address && address.startsWith('0x') && address.length === 42;
    }

    function formatNumber(num) {
      return parseFloat(num || 0).toLocaleString(undefined, {maximumFractionDigits: 2});
    }

    function formatUSD(num) {
      return '$' + parseFloat(num || 0).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function timeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp * 1000) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      return `${Math.floor(seconds / 86400)}d ago`;
    }

    const apiCache = {};
    const API_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

    async function apiCall(endpoint, params = {}) {
      const apiKey = getApiKey();
      if (!apiKey) throw new Error('Please enter your BlockVision API key');

      const url = new URL(`https://api.blockvision.org/v2/monad/${endpoint}`);
      Object.keys(params).forEach(key => {
        if (params[key]) url.searchParams.append(key, params[key]);
      });

      // Check cache
      const cacheKey = url.toString();
      const cached = apiCache[cacheKey];
      if (cached && Date.now() - cached.time < API_CACHE_TTL) {
        return cached.data;
      }

      const response = await fetch(url, {
        headers: { 'X-API-Key': apiKey, 'Accept': 'application/json' }
      });

      if (!response.ok) {
        if (response.status === 401) throw new Error('Invalid API key');
        if (response.status === 429) throw new Error('Rate limit exceeded. Wait and try again.');
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      if (data.code !== 0) throw new Error(data.reason || 'API error');

      apiCache[cacheKey] = { data: data.result, time: Date.now() };
      return data.result;
    }

    // --- token holder snapshot ---
    let snapshotTokenName = '';
    let snapshotTokenSymbol = '';

    async function fetchHolders() {
      const tokenAddress = document.getElementById('snapshotTokenAddress').value.trim();
      const topCount = parseInt(document.getElementById('snapshotTopCount').value) || 50;

      if (!validateAddress(tokenAddress)) {
        showStatus('snapshotStatus', 'Invalid token address', 'error');
        return;
      }

      showStatus('snapshotStatus', 'Fetching token info...', 'loading');
      snapshotData = [];
      snapshotTokenName = '';
      snapshotTokenSymbol = '';
      let cursor = '';
      let page = 1;

      try {
        // Get token name first
        try {
          const contractInfo = await apiCall('contract/detail', { contractAddress: tokenAddress });
          if (contractInfo) {
            snapshotTokenName = contractInfo.token?.name || contractInfo.contractMeta?.contractName || '';
            snapshotTokenSymbol = contractInfo.token?.symbol || '';
          }
        } catch (e) {}

        showStatus('snapshotStatus', 'Fetching holders...', 'loading');

        while (snapshotData.length < topCount) {
          const result = await apiCall('token/holders', {
            contractAddress: tokenAddress,
            limit: Math.min(50, topCount - snapshotData.length),
            cursor: cursor || undefined
          });

          const holders = result.data || [];
          if (holders.length === 0) break;

          snapshotData.push(...holders);
          showStatus('snapshotStatus', `Fetching... Page ${page} (${snapshotData.length} holders)`, 'loading');

          cursor = result.nextPageCursor || '';
          if (!cursor) break;
          page++;
        }

        snapshotData = snapshotData.slice(0, topCount);

        if (snapshotData.length === 0) {
          showStatus('snapshotStatus', 'No holders found', 'error');
          return;
        }

        // Display results with contract icon for contract addresses
        const tbody = document.getElementById('snapshotTable');
        tbody.innerHTML = snapshotData.map((h, i) => {
          const isContract = h.isContract || false;
          const icon = isContract ? '<span title="Contract">üìÑ</span> ' : '';
          return `
            <tr>
              <td>${i + 1}</td>
              <td class="address" title="${h.holder}">${icon}${h.holder}</td>
              <td class="amount">${formatNumber(h.amount)}</td>
              <td class="percentage">${parseFloat(h.percentage || 0).toFixed(2)}%</td>
            </tr>
          `;
        }).join('');

        document.getElementById('snapshotResults').classList.add('active');
        
        // Show token name in header
        const tokenLabel = snapshotTokenSymbol ? `${snapshotTokenName} ($${snapshotTokenSymbol})` : (snapshotTokenName || 'Token');
        document.getElementById('snapshotTokenName').innerHTML = `<span style="color: var(--accent-color);">${tokenLabel}</span> Holders`;
        
        document.getElementById('snapshotTotalHolders').textContent = `${snapshotData.length} holders`;
        document.getElementById('snapshotTime').textContent = new Date().toLocaleString();
        document.getElementById('exportCsvBtn').style.display = 'inline-flex';
        document.getElementById('exportJsonBtn').style.display = 'inline-flex';
        document.getElementById('exportTxtBtn').style.display = 'inline-flex';
        document.getElementById('copyAddressesBtn').style.display = 'inline-flex';

        const successMsg = snapshotTokenSymbol ? `Found ${snapshotData.length} holders of $${snapshotTokenSymbol}!` : `Fetched ${snapshotData.length} holders!`;
        showStatus('snapshotStatus', successMsg, 'success');
      } catch (error) {
        showStatus('snapshotStatus', error.message, 'error');
      }
    }

    function copySnapshotAddresses() {
      if (snapshotData.length === 0) return;
      const addresses = snapshotData.map(h => h.holder).join('\n');
      navigator.clipboard.writeText(addresses).then(() => {
        showStatus('snapshotStatus', `Copied ${snapshotData.length} addresses to clipboard!`, 'success');
      }).catch(() => {
        showStatus('snapshotStatus', 'Failed to copy to clipboard', 'error');
      });
    }

    function exportSnapshotCSV() {
      if (snapshotData.length === 0) return;
      const tokenAddress = document.getElementById('snapshotTokenAddress').value.trim();
      let csv = 'Rank,Address,Amount,Percentage\n';
      snapshotData.forEach((h, i) => {
        csv += `${i + 1},${h.holder},${h.amount},${h.percentage}\n`;
      });
      downloadFile(csv, `${tokenAddress.slice(0, 10)}_holders.csv`, 'text/csv');
    }

    function exportSnapshotJSON() {
      if (snapshotData.length === 0) return;
      const tokenAddress = document.getElementById('snapshotTokenAddress').value.trim();
      const output = {
        token: tokenAddress,
        timestamp: new Date().toISOString(),
        holders: snapshotData.map((h, i) => ({ rank: i + 1, address: h.holder, amount: h.amount, percentage: h.percentage }))
      };
      downloadFile(JSON.stringify(output, null, 2), `${tokenAddress.slice(0, 10)}_holders.json`, 'application/json');
    }

    function exportSnapshotTXT() {
      if (snapshotData.length === 0) return;
      const tokenAddress = document.getElementById('snapshotTokenAddress').value.trim();
      const txt = snapshotData.map(h => h.holder).join('\n');
      downloadFile(txt, `${tokenAddress.slice(0, 10)}_wallets.txt`, 'text/plain');
    }

    // --- wallet checker ---
    async function checkWallet() {
      const walletAddress = document.getElementById('walletAddress').value.trim();

      if (!validateAddress(walletAddress)) {
        showStatus('walletStatus', 'Invalid wallet address', 'error');
        return;
      }

      showStatus('walletStatus', 'Fetching wallet tokens...', 'loading');
      walletTokenData = [];
      walletNftData = [];

      try {
        const result = await apiCall('account/tokens', { address: walletAddress });
        const tokens = result.data || [];
        walletTokenData = tokens;

        const tokenList = document.getElementById('walletTokenList');
        let totalValue = 0;

        if (tokens.length > 0) {
          tokenList.innerHTML = tokens.map(t => {
            const value = parseFloat(t.usdValue || 0);
            totalValue += value;
            return `
              <div class="token-card">
                <div class="token-info">
                  <span class="token-name">${t.symbol || 'Unknown'}</span>
                  <span class="token-address">${t.contractAddress}</span>
                </div>
                <div class="token-balance">
                  <div class="token-amount">${formatNumber(t.balance)}</div>
                  ${value > 0 ? `<div class="token-value">${formatUSD(value)}</div>` : ''}
                </div>
              </div>
            `;
          }).join('');
        } else {
          tokenList.innerHTML = '<div style="color: var(--text-secondary); padding: 10px;">No tokens found</div>';
        }

        document.getElementById('walletTotalTokens').textContent = `${tokens.length} tokens`;
        document.getElementById('walletTotalValue').textContent = totalValue > 0 ? `Total: ${formatUSD(totalValue)}` : '';

        // Fetch NFTs
        showStatus('walletStatus', 'Fetching NFTs...', 'loading');
        try {
          const nftResult = await apiCall('account/nfts', { address: walletAddress });
          const nfts = nftResult.data || [];
          walletNftData = nfts;

          if (nfts.length > 0) {
            document.getElementById('walletNftHeader').style.display = 'flex';
            document.getElementById('walletTotalNfts').textContent = `${nfts.length} NFTs`;
            
            document.getElementById('walletNftList').innerHTML = nfts.map(n => `
              <div class="token-card">
                <div class="token-info">
                  <span class="token-name">üñºÔ∏è ${n.collectionName || n.name || 'Unknown NFT'}</span>
                  <span class="token-address">${n.contractAddress}</span>
                </div>
                <div class="token-balance">
                  <div class="token-amount">${n.tokenId ? `#${n.tokenId}` : `${n.amount || 1}x`}</div>
                </div>
              </div>
            `).join('');
          } else {
            document.getElementById('walletNftHeader').style.display = 'none';
            document.getElementById('walletNftList').innerHTML = '';
          }
        } catch (e) {
          // NFT fetch failed, just skip
          document.getElementById('walletNftHeader').style.display = 'none';
        }

        document.getElementById('walletResults').classList.add('active');
        document.getElementById('exportWalletCsvBtn').style.display = 'inline-flex';
        document.getElementById('copyWalletBtn').style.display = 'inline-flex';

        const totalItems = tokens.length + walletNftData.length;
        showStatus('walletStatus', `Found ${tokens.length} tokens${walletNftData.length > 0 ? ` and ${walletNftData.length} NFTs` : ''}!`, 'success');
      } catch (error) {
        showStatus('walletStatus', error.message, 'error');
      }
    }

    function exportWalletCSV() {
      if (walletTokenData.length === 0 && walletNftData.length === 0) return;
      const walletAddress = document.getElementById('walletAddress').value.trim();
      let csv = 'Type,Name,Contract,Amount,Value\n';
      walletTokenData.forEach(t => {
        csv += `Token,${t.symbol || 'Unknown'},${t.contractAddress},${t.balance},${t.usdValue || 0}\n`;
      });
      walletNftData.forEach(n => {
        csv += `NFT,${n.collectionName || n.name || 'Unknown'},${n.contractAddress},${n.amount || 1},\n`;
      });
      downloadFile(csv, `${walletAddress.slice(0, 10)}_holdings.csv`, 'text/csv');
    }

    function copyWalletAddress() {
      const walletAddress = document.getElementById('walletAddress').value.trim();
      navigator.clipboard.writeText(walletAddress).then(() => {
        showStatus('walletStatus', 'Wallet address copied!', 'success');
      }).catch(() => {
        showStatus('walletStatus', 'Failed to copy', 'error');
      });
    }

    // --- whale watcher ---
    async function watchWhales() {
      const tokenAddress = document.getElementById('whaleTokenAddress').value.trim();
      const whaleCount = parseInt(document.getElementById('whaleCount').value) || 10;

      if (!validateAddress(tokenAddress)) {
        showStatus('whaleStatus', 'Invalid token address', 'error');
        return;
      }

      showStatus('whaleStatus', 'Fetching top holders...', 'loading');

      try {
        // First get top holders
        const holdersResult = await apiCall('token/holders', {
          contractAddress: tokenAddress,
          limit: whaleCount
        });

        const holders = holdersResult.data || [];
        if (holders.length === 0) {
          showStatus('whaleStatus', 'No holders found', 'error');
          return;
        }

        whaleData = [];
        const whaleList = document.getElementById('whaleList');
        whaleList.innerHTML = '';
        
        // Track common holdings across whales
        const tokenCounts = {};

        // For each whale, get their other holdings
        for (let i = 0; i < holders.length; i++) {
          const whale = holders[i];
          showStatus('whaleStatus', `Analyzing whale ${i + 1}/${holders.length}...`, 'loading');
          if (i > 0) await new Promise(r => setTimeout(r, 300));

          try {
            const tokensResult = await apiCall('account/tokens', { address: whale.holder });
            const otherTokens = (tokensResult.data || []).filter(t => 
              t.contractAddress.toLowerCase() !== tokenAddress.toLowerCase()
            ).slice(0, 5);

            // Count token occurrences for common holdings
            otherTokens.forEach(t => {
              const key = t.contractAddress.toLowerCase();
              if (!tokenCounts[key]) {
                tokenCounts[key] = { symbol: t.symbol || 'Unknown', count: 0, contract: t.contractAddress };
              }
              tokenCounts[key].count++;
            });

            whaleData.push({ ...whale, otherTokens });

            const isContract = whale.isContract || false;
            const icon = isContract ? '<span title="Contract">üìÑ</span> ' : '';

            whaleList.innerHTML += `
              <div class="token-card" style="flex-direction: column; align-items: stretch;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                  <div>
                    <strong>#${i + 1}</strong>
                    <span class="token-address" style="margin-left: 10px;">${icon}${whale.holder}</span>
                  </div>
                  <div>
                    <span class="token-amount">${formatNumber(whale.amount)}</span>
                    <span style="color: var(--text-secondary);"> (${parseFloat(whale.percentage).toFixed(2)}%)</span>
                  </div>
                </div>
                ${otherTokens.length > 0 ? `
                  <div style="font-size: 0.85rem; color: var(--text-secondary);">
                    Also holds: ${otherTokens.map(t => `<span style="color: var(--accent-color);">${t.symbol || 'Unknown'}</span>`).join(', ')}
                  </div>
                ` : '<div style="font-size: 0.85rem; color: var(--text-secondary);">No other tokens found</div>'}
              </div>
            `;
          } catch (e) {
            // Skip if we can't get this whale's tokens
            whaleData.push({ ...whale, otherTokens: [] });
          }
        }

        // Show common holdings analysis
        const commonTokens = Object.values(tokenCounts)
          .filter(t => t.count >= 2)
          .sort((a, b) => b.count - a.count)
          .slice(0, 5);

        if (commonTokens.length > 0) {
          const commonHtml = `
            <div class="token-card" style="background: rgba(123, 63, 228, 0.1); border-color: var(--accent-color);">
              <div style="width: 100%;">
                <div style="font-weight: 700; margin-bottom: 8px; color: var(--accent-color);">üî• Common Holdings</div>
                <div style="font-size: 0.9rem;">
                  ${commonTokens.map(t => `<span style="margin-right: 15px;"><strong>${t.symbol}</strong> <span style="color: var(--text-secondary);">(${t.count} whales)</span></span>`).join('')}
                </div>
              </div>
            </div>
          `;
          whaleList.insertAdjacentHTML('afterbegin', commonHtml);
        }

        document.getElementById('whaleResults').classList.add('active');
        document.getElementById('exportWhaleCsvBtn').style.display = 'inline-flex';
        document.getElementById('exportWhaleTxtBtn').style.display = 'inline-flex';
        showStatus('whaleStatus', `Analyzed ${holders.length} whales!`, 'success');
      } catch (error) {
        showStatus('whaleStatus', error.message, 'error');
      }
    }

    function exportWhaleCSV() {
      if (whaleData.length === 0) return;
      const tokenAddress = document.getElementById('whaleTokenAddress').value.trim();
      let csv = 'Rank,Address,Amount,Percentage,Other Holdings\n';
      whaleData.forEach((w, i) => {
        const otherHoldings = w.otherTokens ? w.otherTokens.map(t => t.symbol || 'Unknown').join('; ') : '';
        csv += `${i + 1},${w.holder},${w.amount},${w.percentage},"${otherHoldings}"\n`;
      });
      downloadFile(csv, `${tokenAddress.slice(0, 10)}_whales.csv`, 'text/csv');
    }

    function exportWhaleTXT() {
      if (whaleData.length === 0) return;
      const tokenAddress = document.getElementById('whaleTokenAddress').value.trim();
      const txt = whaleData.map(w => w.holder).join('\n');
      downloadFile(txt, `${tokenAddress.slice(0, 10)}_whale_wallets.txt`, 'text/plain');
    }

    // --- diamond hand analyzer ---
    let diamondTokenName = '';
    let diamondTokenSymbol = '';

    async function analyzeDiamondHands() {
      const tokenAddress = document.getElementById('diamondTokenAddress').value.trim();
      const analyzeCount = parseInt(document.getElementById('diamondCount').value) || 25;

      if (!validateAddress(tokenAddress)) {
        showStatus('diamondStatus', 'Invalid token address', 'error');
        return;
      }

      showStatus('diamondStatus', 'Fetching token info...', 'loading');
      diamondData = [];
      diamondTokenName = '';
      diamondTokenSymbol = '';

      try {
        // Get token name first
        try {
          const contractInfo = await apiCall('contract/detail', { contractAddress: tokenAddress });
          if (contractInfo) {
            diamondTokenName = contractInfo.token?.name || contractInfo.contractMeta?.contractName || '';
            diamondTokenSymbol = contractInfo.token?.symbol || '';
          }
        } catch (e) {}

        showStatus('diamondStatus', 'Fetching top holders...', 'loading');

        // Get top holders
        const holdersResult = await apiCall('token/holders', {
          contractAddress: tokenAddress,
          limit: analyzeCount
        });

        const holders = holdersResult.data || [];
        if (holders.length === 0) {
          showStatus('diamondStatus', 'No holders found', 'error');
          return;
        }

        // Analyze each holder
        let totalSupplyHeld = 0;
        const tierCounts = { og: 0, diamond: 0, accumulator: 0, steady: 0, paper: 0 };
        const tierSupply = { og: 0, diamond: 0, accumulator: 0, steady: 0, paper: 0 };

        for (let i = 0; i < holders.length; i++) {
          const holder = holders[i];
          showStatus('diamondStatus', `Analyzing holder ${i + 1}/${holders.length}...`, 'loading');
          if (i > 0) await new Promise(r => setTimeout(r, 300));

          const percentage = parseFloat(holder.percentage || 0);
          totalSupplyHeld += percentage;

          let otherTokenCount = 0;
          let focusScore = 100; // Start with max focus

          // Get other holdings to calculate focus score
          try {
            const tokensResult = await apiCall('account/tokens', { address: holder.holder });
            const otherTokens = (tokensResult.data || []).filter(t => 
              t.contractAddress.toLowerCase() !== tokenAddress.toLowerCase()
            );
            otherTokenCount = otherTokens.length;
            // More tokens = less focused = lower score
            focusScore = Math.max(0, 100 - (otherTokenCount * 5));
          } catch (e) {
            // If we can't get holdings, assume moderate focus
            focusScore = 50;
          }

          // Calculate diamond score
          // Position weight (40%): Higher % = higher score
          const positionScore = Math.min(100, percentage * 10);
          
          // Rank weight (30%): Lower rank = higher score (early holder proxy)
          const rankScore = Math.max(0, 100 - (i * 4));
          
          // Focus weight (30%): Fewer other tokens = higher score
          const diamondScore = Math.round(
            (positionScore * 0.4) + (rankScore * 0.3) + (focusScore * 0.3)
          );

          // Determine tier based on score and rank
          let tier = 'steady';
          if (i < 5 && diamondScore >= 70) {
            tier = 'og';
          } else if (diamondScore >= 60) {
            tier = 'diamond';
          } else if (focusScore >= 70) {
            tier = 'accumulator';
          } else if (diamondScore >= 30) {
            tier = 'steady';
          } else {
            tier = 'paper';
          }

          tierCounts[tier]++;
          tierSupply[tier] += percentage;

          diamondData.push({
            rank: i + 1,
            address: holder.holder,
            amount: holder.amount,
            percentage: percentage,
            isContract: holder.isContract || false,
            otherTokenCount: otherTokenCount,
            diamondScore: diamondScore,
            tier: tier
          });
        }

        // Sort by diamond score
        diamondData.sort((a, b) => b.diamondScore - a.diamondScore);

        // Calculate overall diamond strength
        const diamondStrength = Math.round(tierSupply.og + tierSupply.diamond + tierSupply.accumulator);

        // Render summary
        const tokenLabel = diamondTokenSymbol ? `$${diamondTokenSymbol}` : 'Token';
        document.getElementById('diamondSummary').innerHTML = `
          <div class="diamond-stat highlight">
            <div class="stat-icon">üíé</div>
            <div class="stat-label">Diamond Strength</div>
            <div class="stat-value diamond">${diamondStrength}%</div>
          </div>
          <div class="diamond-stat">
            <div class="stat-icon">üèÜ</div>
            <div class="stat-label">OG Holders</div>
            <div class="stat-value gold">${tierCounts.og}</div>
          </div>
          <div class="diamond-stat">
            <div class="stat-icon">üíé</div>
            <div class="stat-label">Diamond Hands</div>
            <div class="stat-value diamond">${tierCounts.diamond}</div>
          </div>
          <div class="diamond-stat">
            <div class="stat-icon">üìä</div>
            <div class="stat-label">Analyzed</div>
            <div class="stat-value">${holders.length}</div>
          </div>
        `;

        // Render holder list
        const diamondList = document.getElementById('diamondList');
        diamondList.innerHTML = diamondData.map((h, i) => {
          const tierLabels = {
            og: 'üèÜ OG',
            diamond: 'üíé Diamond',
            accumulator: 'üìà Stacker',
            steady: '‚öñÔ∏è Steady',
            paper: 'üìÑ Paper'
          };
          const contractIcon = h.isContract ? '<span title="Contract">üìÑ</span> ' : '';
          
          return `
            <div class="diamond-card" id="diamond-card-${i}">
              <div class="rank ${i < 3 ? 'top3' : ''}">#${i + 1}</div>
              <div class="holder-info">
                <div class="holder-address">${contractIcon}${h.address}</div>
                <div class="holder-stats">
                  <span><strong>${formatNumber(h.amount)}</strong> ${tokenLabel}</span>
                  <span>${h.percentage.toFixed(2)}%</span>
                  <span>${h.otherTokenCount} other tokens</span>
                </div>
                <div class="deep-dive-results" id="deep-dive-${i}" style="display: none;"></div>
              </div>
              <div class="diamond-score">
                <div class="score-value">${h.diamondScore}</div>
                <div class="score-label">Score</div>
              </div>
              <span class="tier-badge ${h.tier}">${tierLabels[h.tier]}</span>
              <button class="btn secondary deep-dive-btn" id="deep-btn-${i}" onclick="deepDiveWallet('${h.address}', ${i})" title="Get buy/sell history">üîç</button>
            </div>
          `;
        }).join('');

        // Update header
        if (diamondTokenSymbol) {
          document.getElementById('diamondTokenName').innerHTML = `<span style="color: var(--accent-color);">$${diamondTokenSymbol}</span> Diamond Rankings`;
        }

        document.getElementById('diamondResults').classList.add('active');
        document.getElementById('exportDiamondCsvBtn').style.display = 'inline-flex';
        document.getElementById('exportDiamondTxtBtn').style.display = 'inline-flex';

        showStatus('diamondStatus', `Analyzed ${holders.length} holders! Diamond Strength: ${diamondStrength}%`, 'success');
      } catch (error) {
        showStatus('diamondStatus', error.message, 'error');
      }
    }

    function exportDiamondCSV() {
      if (diamondData.length === 0) return;
      const tokenAddress = document.getElementById('diamondTokenAddress').value.trim();
      let csv = 'Rank,Address,Amount,Percentage,Diamond Score,Tier,Other Tokens,Is Contract\n';
      diamondData.forEach((h, i) => {
        csv += `${i + 1},${h.address},${h.amount},${h.percentage},${h.diamondScore},${h.tier},${h.otherTokenCount},${h.isContract}\n`;
      });
      downloadFile(csv, `${tokenAddress.slice(0, 10)}_diamond_hands.csv`, 'text/csv');
    }

    function exportDiamondTXT() {
      if (diamondData.length === 0) return;
      const tokenAddress = document.getElementById('diamondTokenAddress').value.trim();
      // Export only diamond hands (OG, Diamond, Accumulator tiers)
      const diamondHands = diamondData.filter(h => ['og', 'diamond', 'accumulator'].includes(h.tier));
      const txt = diamondHands.map(h => h.address).join('\n');
      downloadFile(txt, `${tokenAddress.slice(0, 10)}_diamond_wallets.txt`, 'text/plain');
    }

    async function deepDiveWallet(walletAddress, index) {
      const tokenAddress = document.getElementById('diamondTokenAddress').value.trim();
      const btn = document.getElementById(`deep-btn-${index}`);
      const resultsDiv = document.getElementById(`deep-dive-${index}`);
      
      // If already showing, toggle off
      if (resultsDiv.style.display === 'block') {
        resultsDiv.style.display = 'none';
        btn.textContent = 'üîç';
        return;
      }

      btn.classList.add('loading');
      btn.textContent = '‚è≥';
      resultsDiv.innerHTML = '<div style="color: var(--text-secondary);">Loading activity...</div>';
      resultsDiv.style.display = 'block';

      try {
        // Fetch wallet activity
        const result = await apiCall('account/activity', { 
          address: walletAddress,
          limit: 50
        });

        const activities = result.data || [];
        
        // Filter for this token's transactions
        let totalBought = 0;
        let totalSold = 0;
        let buyCount = 0;
        let sellCount = 0;
        let firstTxTime = null;
        let lastTxTime = null;

        activities.forEach(tx => {
          const timestamp = tx.timestamp;
          if (!firstTxTime || timestamp < firstTxTime) firstTxTime = timestamp;
          if (!lastTxTime || timestamp > lastTxTime) lastTxTime = timestamp;

          // Check addTokens (buys/receives)
          if (tx.addTokens) {
            tx.addTokens.forEach(token => {
              if (token.contractAddress?.toLowerCase() === tokenAddress.toLowerCase()) {
                const usdValue = parseFloat(token.usdValue || 0);
                totalBought += usdValue;
                buyCount++;
              }
            });
          }

          // Check subTokens (sells/sends)
          if (tx.subTokens) {
            tx.subTokens.forEach(token => {
              if (token.contractAddress?.toLowerCase() === tokenAddress.toLowerCase()) {
                const usdValue = parseFloat(token.usdValue || 0);
                totalSold += usdValue;
                sellCount++;
              }
            });
          }
        });

        // Calculate metrics
        const netPosition = totalBought - totalSold;
        const holdDays = firstTxTime ? Math.floor((Date.now() - firstTxTime) / (1000 * 60 * 60 * 24)) : 0;
        
        // Determine verdict
        let verdict = '';
        let verdictClass = '';
        if (totalSold === 0 && totalBought > 0) {
          verdict = 'üíé Never sold - True Diamond Hand!';
          verdictClass = 'green';
        } else if (netPosition > 0) {
          verdict = 'üìà Net accumulator - Buying more than selling';
          verdictClass = 'green';
        } else if (netPosition < 0) {
          verdict = 'üìâ Net seller - Sold more than bought';
          verdictClass = 'red';
        } else if (buyCount === 0 && sellCount === 0) {
          verdict = 'üîÑ No token activity found in recent history';
          verdictClass = '';
        } else {
          verdict = '‚öñÔ∏è Balanced - Similar buy/sell activity';
          verdictClass = '';
        }

        resultsDiv.innerHTML = `
          <div class="dive-grid">
            <div class="dive-stat">
              <div class="label">Total Bought</div>
              <div class="value green">${formatUSD(totalBought)}</div>
            </div>
            <div class="dive-stat">
              <div class="label">Total Sold</div>
              <div class="value red">${formatUSD(totalSold)}</div>
            </div>
            <div class="dive-stat">
              <div class="label">Net Position</div>
              <div class="value ${netPosition >= 0 ? 'green' : 'red'}">${netPosition >= 0 ? '+' : ''}${formatUSD(netPosition)}</div>
            </div>
            <div class="dive-stat">
              <div class="label">Hold Duration</div>
              <div class="value blue">${holdDays > 0 ? holdDays + ' days' : 'N/A'}</div>
            </div>
          </div>
          <div class="dive-summary">
            <strong>${verdict}</strong><br>
            <span style="font-size: 0.8rem;">${buyCount} buys, ${sellCount} sells in last 50 transactions</span>
          </div>
        `;

        btn.textContent = '‚úì';
        btn.classList.remove('loading');

      } catch (error) {
        resultsDiv.innerHTML = `<div style="color: var(--error-color);">Failed to load: ${error.message}</div>`;
        btn.textContent = 'üîç';
        btn.classList.remove('loading');
      }
    }

    // --- nft holder snapshot ---

    function exportNFTTXT() {
      if (nftData.length === 0) return;
      const nftAddress = document.getElementById('nftAddress').value.trim();
      const txt = nftData.map(h => h.ownerAddress || h.holder || h.address).join('\n');
      downloadFile(txt, `${nftAddress.slice(0, 10)}_nft_wallets.txt`, 'text/plain');
    }
    let nftCollectionName = '';

    async function fetchNFTHolders() {
      const nftAddress = document.getElementById('nftAddress').value.trim();
      const topCount = parseInt(document.getElementById('nftTopCount').value) || 50;

      if (!validateAddress(nftAddress)) {
        showStatus('nftStatus', 'Invalid NFT contract address', 'error');
        return;
      }

      showStatus('nftStatus', 'Fetching NFT collection info...', 'loading');
      nftData = [];
      nftCollectionName = '';

      try {
        // First, try to get the collection name from contract detail
        try {
          const contractInfo = await apiCall('contract/detail', { contractAddress: nftAddress });
          if (contractInfo) {
            nftCollectionName = contractInfo.nft?.name || contractInfo.contractMeta?.contractName || contractInfo.token?.name || '';
          }
        } catch (e) {
          // Continue without name if this fails
        }

        showStatus('nftStatus', 'Fetching NFT holders...', 'loading');

        // Try multiple possible endpoint paths
        const endpoints = ['nft/collection/holders', 'collection/holders', 'nft/holders'];
        let workingEndpoint = null;
        let result = null;
        let lastError = null;

        for (const endpoint of endpoints) {
          try {
            result = await apiCall(endpoint, {
              contractAddress: nftAddress,
              limit: Math.min(50, topCount)
            });
            if (result && result.data) {
              workingEndpoint = endpoint;
              break;
            }
          } catch (e) {
            lastError = e;
            continue;
          }
        }

        if (!result || !result.data) {
          throw lastError || new Error('Could not fetch NFT holders');
        }

        // Process first page
        nftData.push(...(result.data || []));
        let nextCursor = result.nextPageCursor || '';

        // Fetch remaining pages
        while (nftData.length < topCount && nextCursor) {
          showStatus('nftStatus', `Fetching... (${nftData.length} holders)`, 'loading');
          
          result = await apiCall(workingEndpoint, {
            contractAddress: nftAddress,
            limit: Math.min(50, topCount - nftData.length),
            cursor: nextCursor
          });

          const pageHolders = result.data || [];
          if (pageHolders.length === 0) break;

          nftData.push(...pageHolders);
          nextCursor = result.nextPageCursor || '';
        }

        nftData = nftData.slice(0, topCount);

        if (nftData.length === 0) {
          showStatus('nftStatus', 'No holders found. This collection may not be indexed yet.', 'error');
          return;
        }

        const tbody = document.getElementById('nftTable');
        const totalNFTs = nftData.reduce((sum, h) => sum + parseInt(h.amount || h.tokenCount || 1), 0);

        tbody.innerHTML = nftData.map((h, i) => {
          const count = parseInt(h.amount || h.tokenCount || 1);
          const pct = h.percentage || ((count / totalNFTs) * 100).toFixed(2);
          const addr = h.ownerAddress || h.holder || h.address;
          return `
            <tr>
              <td>${i + 1}</td>
              <td class="address" title="${addr}">${addr}</td>
              <td class="amount">${count}</td>
              <td class="percentage">${parseFloat(pct).toFixed(2)}%</td>
            </tr>
          `;
        }).join('');

        document.getElementById('nftResults').classList.add('active');
        
        // Show collection name in title
        if (nftCollectionName) {
          document.getElementById('nftCollectionTitle').innerHTML = `<span style="color: var(--accent-color);">${nftCollectionName}</span> Holders`;
        } else {
          document.getElementById('nftCollectionTitle').textContent = 'NFT Holders';
        }
        
        document.getElementById('nftTotalHolders').textContent = `${nftData.length} holders`;
        document.getElementById('nftTotalSupply').textContent = `${totalNFTs} total NFTs`;
        
        document.getElementById('exportNftCsvBtn').style.display = 'inline-flex';
        document.getElementById('exportNftTxtBtn').style.display = 'inline-flex';
        document.getElementById('copyNftAddressesBtn').style.display = 'inline-flex';

        const successMsg = nftCollectionName ? `Found ${nftData.length} holders of ${nftCollectionName}!` : `Fetched ${nftData.length} holders!`;
        showStatus('nftStatus', successMsg, 'success');
      } catch (error) {
        // If collection/holders fails, the NFT may not be indexed yet
        if (error.message.includes('404')) {
          showStatus('nftStatus', 'This NFT collection is not indexed yet. Try again later or check the contract address.', 'error');
        } else {
          showStatus('nftStatus', error.message, 'error');
        }
      }
    }

    function exportNFTCSV() {
      if (nftData.length === 0) return;
      const nftAddress = document.getElementById('nftAddress').value.trim();
      let csv = 'Rank,Address,NFTs Held\n';
      nftData.forEach((h, i) => {
        const addr = h.ownerAddress || h.holder || h.address;
        csv += `${i + 1},${addr},${h.amount || h.tokenCount || 1}\n`;
      });
      downloadFile(csv, `${nftAddress.slice(0, 10)}_nft_holders.csv`, 'text/csv');
    }

    function copyNFTAddresses() {
      if (nftData.length === 0) return;
      const addresses = nftData.map(h => h.ownerAddress || h.holder || h.address).join('\n');
      navigator.clipboard.writeText(addresses).then(() => {
        showStatus('nftStatus', `Copied ${nftData.length} addresses to clipboard!`, 'success');
      }).catch(() => {
        showStatus('nftStatus', 'Failed to copy to clipboard', 'error');
      });
    }

  </script>

  <script>
    // ‚îÄ‚îÄ Page Transition ‚îÄ‚îÄ
    (function() {
      const pt = document.getElementById('pageTransition');
      if (!pt) return;
      let navigating = false;

      // Entrance: hide overlay elements after animation completes
      const hideTimeout = setTimeout(() => {
        pt.querySelector('.pt-overlay').style.display = 'none';
        pt.querySelector('.pt-logo').style.display = 'none';
        pt.querySelector('.pt-glow').style.display = 'none';
      }, 1600);

      // Exit: intercept back link to emo.html
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (!link) return;
        const href = link.getAttribute('href');
        if (href !== 'emo.html' && !href.endsWith('/emo.html')) return;

        e.preventDefault();
        if (navigating) return;
        navigating = true;
        clearTimeout(hideTimeout);
        pt.querySelector('.pt-overlay').style.display = '';
        pt.querySelector('.pt-logo').style.display = '';
        pt.querySelector('.pt-glow').style.display = '';
        pt.classList.add('exit-active');
        sessionStorage.setItem('pt-entering', '1');

        setTimeout(() => {
          window.location.href = href;
        }, 1400);
      });
    })();
  </script>
</body>
</html>
